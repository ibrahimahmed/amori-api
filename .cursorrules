# Amori API - Cursor Rules

You are a staff TypeScript programmer with experience in Bun, Elysia.js, and modern backend development with a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## Tech Stack

- **Runtime:** Bun
- **Framework:** Elysia.js
- **Database:** PostgreSQL with Kysely query builder
- **Auth:** Supabase Auth
- **Cache:** Redis (ioredis)
- **Email:** Resend
- **AI:** OpenAI
- **Validation:** TypeBox (Elysia's built-in)

## TypeScript General Guidelines

### Basic Principles

- Use English for all code and documentation.
- Always declare the type of each variable and function (parameters and return value).
  - Avoid using `any`. Use `unknown` if type is truly unknown.
  - Create necessary types and interfaces.
- Use JSDoc to document public functions and complex logic.
- Don't leave blank lines within a function.
- One main export per file (can have multiple supporting exports).
- Prefer `const` over `let`. Never use `var`.

### Nomenclature

- Use PascalCase for classes, interfaces, and types.
- Use camelCase for variables, functions, and methods.
- Use kebab-case for file and directory names.
- Use UPPERCASE for environment variables and constants.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: `isLoading`, `hasError`, `canDelete`, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, HTTP, etc.
  - Except for well-known abbreviations:
    - `i`, `j` for loops
    - `err`, `error` for errors
    - `ctx` for Elysia context
    - `req`, `res` for request/response
    - `db` for database client
    - `id` for identifiers

### Functions

- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use `isX` or `hasX`, `canX`, etc.
  - If it doesn't return anything, use `executeX` or `saveX`, `updateX`, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using object destructuring.
- Use a single level of abstraction.

### Data

- Don't abuse primitive types and encapsulate data in composite types.
- Prefer immutability for data.
  - Use `readonly` for data that doesn't change.
  - Use `as const` for literals that don't change.
- Use TypeBox (Elysia's `t` object) for runtime validation.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

### Error Handling

- Use exceptions to handle errors you don't expect.
- Always set appropriate HTTP status codes.
- Return consistent error response format:
  ```typescript
  {
    success: false,
    error: "Error message"
  }
  ```
- Return consistent success response format:
  ```typescript
  {
    success: true,
    data: {...},
    message?: "Optional message"
  }
  ```
- Use global error handler middleware for uncaught exceptions.

### Testing

- Follow the Arrange-Act-Assert convention for tests.
- Name test variables clearly.
  - Follow the convention: `inputX`, `mockX`, `actualX`, `expectedX`, etc.
- Write unit tests for each public function.
- Use Bun's built-in test runner.

## Specific to Amori API Architecture

### Project Structure

```
src/
├── config/           # Environment configuration
├── libs/             # Shared libraries and clients
│   ├── cache/        # Redis client
│   ├── db/           # Kysely database client & schema
│   ├── email/        # Email service (Resend)
│   ├── logger/       # Logging utilities
│   ├── openai/       # OpenAI integration
│   └── supabase/     # Supabase client
├── middlewares/      # Elysia global middlewares
├── modules/          # Feature modules
│   └── [feature]/
│       ├── index.ts              # Module exports
│       ├── [feature].routes.ts   # Elysia route definitions
│       ├── [feature].service.ts  # Business logic
│       └── [feature].middleware.ts (optional)
├── types/            # Global TypeScript types
└── index.ts          # Application entry point
```

### Module Architecture

Each module should follow this pattern:

1. **Routes File** (`*.routes.ts`)
   - Export an Elysia instance with route prefix
   - Define all HTTP endpoints
   - Use TypeBox for validation
   - Include Swagger documentation
   - Apply middlewares as needed

2. **Service File** (`*.service.ts`)
   - Contain business logic
   - Handle database operations
   - One class per service
   - Methods should be focused and single-purpose

3. **Index File** (`index.ts`)
   - Re-export routes and services
   - Keep it minimal

### Elysia Route Guidelines

- Always use route prefixes in module definition:
  ```typescript
  export const userRoutes = new Elysia({ prefix: "/users" })
  ```

- Always provide TypeBox validation for request bodies:
  ```typescript
  .post("/", async ({ body }) => {...}, {
    body: t.Object({
      email: t.String({ format: "email" }),
      name: t.String()
    })
  })
  ```

- Always add Swagger documentation:
  ```typescript
  {
    detail: {
      tags: ["users"],
      summary: "Create user",
      description: "Create a new user account",
      security: [{ bearerAuth: [] }] // if protected
    }
  }
  ```

- Use explicit typing for context destructuring:
  ```typescript
  async ({ user, body }: { user: AuthUser; body: CreateUserDto }) => {...}
  ```

- Apply authentication middleware before protected routes:
  ```typescript
  export const userRoutes = new Elysia({ prefix: "/users" })
    .post("/public", ...) // public route
    .use(authMiddleware)  // everything after needs auth
    .get("/me", ...)      // protected route
  ```

### Database Guidelines (Kysely)

- Import db client: `import { db } from "../../libs/db/client"`
- Use type-safe queries:
  ```typescript
  const user = await db
    .selectFrom("users")
    .selectAll()
    .where("id", "=", userId)
    .executeTakeFirst();
  ```

- Use transactions for multi-step operations:
  ```typescript
  await db.transaction().execute(async (trx) => {
    // multiple operations
  });
  ```

- Define schema types in `libs/db/schema/[table].model.ts`

### Authentication Guidelines

- Protected routes must use `authMiddleware`
- Access user from context: `{ user }: { user: AuthUser }`
- User object contains: `id`, `email`, `name`, `avatar_url`
- Use `supabaseAnon` for client-facing auth operations
- Use `supabase` (service role) for admin operations

#### Auth Middleware Type Propagation

When creating auth middleware with Elysia, use `{ as: "global" }` to propagate types:

```typescript
// In auth.middleware.ts
export const authMiddleware = new Elysia({ name: "auth" })
  .derive({ as: "global" }, async ({ headers, set }): Promise<{ user: AuthUser }> => {
    // ... authentication logic
    return { user };
  });
```

Without `{ as: "global" }`, the `user` property won't be typed in consuming routes:
```typescript
// ❌ Without as: "global" - TypeScript error: Property 'user' does not exist
.get("/", ({ user }) => { ... })

// ✅ With as: "global" - Works correctly
.get("/", ({ user }) => { ... })
```

### Caching Guidelines (Redis)

- Import redis: `import { redis } from "../../libs/cache"`
- Use descriptive key patterns: `otp:${email}`, `user:${id}`, `people:list:${userId}`
- Always set expiration for temporary data:
  ```typescript
  await redis.setex(key, ttlSeconds, value);
  ```
- Handle cache misses gracefully
- Implement cache invalidation on write operations

#### Caching Pattern in Services

```typescript
// Cache TTL constants
private readonly CACHE_TTL = {
  LIST: 120,      // 2 minutes for lists
  PROFILE: 300,   // 5 minutes for profiles
  UPCOMING: 60,   // 1 minute for time-sensitive data
} as const;

// Cache key generation
private getCacheKey(type: string, ...args: string[]): string {
  return `people:${type}:${args.join(":")}`;
}

// Get from cache helper
private async getCache<T>(key: string): Promise<T | null> {
  try {
    const cached = await redis.get(key);
    return cached ? JSON.parse(cached) : null;
  } catch {
    return null; // Gracefully handle cache errors
  }
}

// Set cache helper
private async setCache(key: string, data: unknown, ttl: number): Promise<void> {
  try {
    await redis.setex(key, ttl, JSON.stringify(data));
  } catch {
    // Log but don't fail on cache errors
  }
}

// Invalidate cache on writes
async invalidateCache(userId: string): Promise<void> {
  try {
    const keys = await redis.keys(`people:*:${userId}*`);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  } catch {
    // Log but don't fail
  }
}
```

#### When to Cache

- **Cache**: List queries, profile lookups, upcoming events
- **Don't cache**: Filtered queries (relation_type), write operations
- **Invalidate on**: Create, Update, Delete operations

### Email Guidelines (Resend)

- Import: `import { sendEmail } from "../../libs/email"`
- Always check if email is enabled: `isEmailEnabled()`
- Use HTML templates for better UX
- Include plain text fallback
- Handle email failures gracefully

### Logging Guidelines

- Import: `import { logger } from "../../libs/logger"`
- Use appropriate log levels:
  - `logger.info()` - General information
  - `logger.error()` - Errors with Error object
  - `logger.warn()` - Warnings
  - `logger.debug()` - Debug info (dev only)
- Never use `console.log` - always use logger
- Include context in logs:
  ```typescript
  logger.error("Failed to create user", error, { userId, email });
  ```

### API Response Guidelines

- Always return consistent response structure
- Success responses:
  ```typescript
  return {
    success: true,
    data: result,
    message?: "Optional success message"
  };
  ```

- Error responses:
  ```typescript
  set.status = 400; // or appropriate code
  return {
    success: false,
    error: "Error message"
  };
  ```

- Use appropriate HTTP status codes:
  - 200: Success
  - 201: Created
  - 204: No Content
  - 400: Bad Request
  - 401: Unauthorized
  - 403: Forbidden
  - 404: Not Found
  - 500: Internal Server Error

### Security Guidelines

- Never expose sensitive data in responses
- Always validate and sanitize inputs
- Use parameterized queries (Kysely handles this)
- Implement rate limiting for sensitive endpoints
- Use environment variables for secrets
- Never commit `.env` files
- Prevent email enumeration in auth flows
- Use time-limited tokens/codes
- Delete sensitive data after use (OTPs, tokens)

### Performance Guidelines

- Use Redis for caching frequent queries
- Use database indexes appropriately
- Implement pagination for list endpoints
- Use connection pooling (configured in db client)
- Avoid N+1 queries - use joins or batch queries
- Use background jobs for long-running tasks

### Documentation Guidelines

- Document all public APIs with Swagger/OpenAPI
- Include request/response examples
- Document error scenarios
- Keep README.md updated
- Document environment variables in `.env.example`
- Add JSDoc for complex business logic

### Code Review Checklist

Before committing, verify:

#### Code Quality
- [ ] TypeScript types are properly defined
- [ ] No `any` types used (except in test mocks)
- [ ] Error handling is implemented with ServiceError
- [ ] Logging uses logger, not console
- [ ] Code follows naming conventions
- [ ] Functions are short and focused
- [ ] No magic numbers or strings

#### API Standards
- [ ] Authentication is applied to protected routes
- [ ] Input validation with TypeBox
- [ ] Swagger documentation added
- [ ] Consistent response format (`{ success, data/error }`)
- [ ] Appropriate HTTP status codes
- [ ] No sensitive data exposed

#### Performance
- [ ] Caching implemented for read-heavy endpoints
- [ ] Cache invalidation on write operations
- [ ] Optimized database queries (avoid N+1)
- [ ] Environment variables used for config

#### Testing
- [ ] Unit tests written for new service methods
- [ ] Route tests cover happy path and error cases
- [ ] Mocks used (no real DB/Redis connections)
- [ ] All tests pass (`bun test`)
- [ ] Edge cases covered (empty results, invalid input)

### Git Commit Guidelines

- Use conventional commits format:
  - `feat:` new feature
  - `fix:` bug fix
  - `docs:` documentation
  - `refactor:` code refactoring
  - `test:` adding tests
  - `chore:` maintenance
- Write clear, descriptive commit messages
- Keep commits focused and atomic

### Testing Conventions

#### Test Structure

```
tests/
├── setup.ts                           # Preloaded env setup
├── routes/
│   └── health.test.ts                 # Health endpoint tests
└── modules/
    └── [feature]/
        ├── [feature].routes.test.ts   # Route/controller tests
        └── [feature].service.test.ts  # Service/business logic tests
```

#### Test Configuration

Tests use `bunfig.toml` preload for environment setup:
```toml
[test]
preload = ["./tests/setup.ts"]
```

The `tests/setup.ts` sets required env vars before test imports:
```typescript
process.env.NODE_ENV = "test";
process.env.DATABASE_URL = "postgres://test:test@localhost:5432/test";
process.env.REDIS_URL = "redis://localhost:6379";
// ... other required env vars
```

#### Mocking Strategy

**NEVER use real database or Redis connections in tests.** Mock everything:

1. **Route Tests** - Mock the service layer entirely:
```typescript
const mockPeopleService = {
  getAll: mock((_userId: string) => Promise.resolve([mockPerson])),
  create: mock((_data: Record<string, unknown>) => Promise.resolve(mockPerson)),
  // ... other methods
};
```

2. **Service Tests** - Mock database (Kysely) and cache (Redis):
```typescript
/* eslint-disable @typescript-eslint/no-explicit-any */
// Mock Redis
const mockRedisGet = mock((): Promise<any> => Promise.resolve(null));
const mockRedisSetex = mock((): Promise<any> => Promise.resolve("OK"));
const mockRedisKeys = mock((): Promise<any> => Promise.resolve([]));
const mockRedisDel = mock((): Promise<any> => Promise.resolve(1));

// Mock Kysely database chain
const mockExecute = mock((): Promise<any> => Promise.resolve([]));
const mockExecuteTakeFirst = mock((): Promise<any> => Promise.resolve(null));
const mockSqlExecute = mock((): Promise<any> => Promise.resolve({ rows: [] }));

const mockDbChain = {
  selectFrom: () => mockDbChain,
  insertInto: () => mockDbChain,
  updateTable: () => mockDbChain,
  deleteFrom: () => mockDbChain,
  selectAll: () => mockDbChain,
  select: () => mockDbChain,
  values: () => mockDbChain,
  set: () => mockDbChain,
  where: () => mockDbChain,
  orderBy: () => mockDbChain,
  returningAll: () => mockDbChain,
  execute: mockExecute,
  executeTakeFirst: mockExecuteTakeFirst,
};

// Mock SQL template
const mockSql = () => ({ execute: mockSqlExecute });

// Setup module mocks BEFORE imports
mock.module("../../../src/libs/cache", () => ({
  redis: { get: mockRedisGet, setex: mockRedisSetex, keys: mockRedisKeys, del: mockRedisDel },
}));
mock.module("../../../src/libs/db/client", () => ({ db: mockDbChain }));
mock.module("kysely", () => ({ sql: mockSql }));
mock.module("../../../src/libs/logger", () => ({
  logger: { info: () => {}, error: () => {}, warn: () => {}, debug: () => {} },
}));
```

#### Testing Elysia Routes

Use `app.handle()` instead of making real HTTP calls:
```typescript
function createTestApp() {
  return new Elysia({ prefix: "/people" })
    .derive(() => ({
      user: { id: TEST_USER_ID, email: "test@example.com", name: "Test", avatar_url: null },
    }))
    .get("/", async ({ user, query, set }) => {
      try {
        const people = await mockPeopleService.getAll(user.id);
        return { success: true, data: people };
      } catch (error) {
        set.status = 500;
        return { success: false, error: "Internal server error" };
      }
    });
}

// In tests:
it("should return all people", async () => {
  const response = await app.handle(new Request("http://localhost/people"));
  const data = await response.json();
  expect(response.status).toBe(200);
  expect(data.success).toBe(true);
});
```

#### AAA Pattern (Arrange-Act-Assert)

```typescript
it("should return person when found", async () => {
  // Arrange
  mockExecuteTakeFirst.mockImplementation(() => Promise.resolve(mockPerson));
  
  // Act
  const result = await service.getById(TEST_USER_ID, TEST_PERSON_ID);
  
  // Assert
  expect(result).toEqual(mockPerson);
});
```

#### Reset Mocks Before Each Test

```typescript
beforeEach(() => {
  service = new PeopleService();
  // Reset all mocks
  mockRedisGet.mockReset();
  mockExecute.mockReset();
  // Set defaults
  mockRedisGet.mockImplementation(() => Promise.resolve(null));
  mockExecute.mockImplementation(() => Promise.resolve([]));
});
```

#### Test Categories to Cover

1. **Happy Path** - Normal successful operations
2. **Error Handling** - Database errors, validation errors
3. **Edge Cases** - Empty results, null values, special characters
4. **Cache Behavior** - Cache hits, cache misses, cache invalidation
5. **Input Validation** - Invalid UUIDs, missing fields, malformed data
6. **Response Format** - Consistent success/error structure

#### JSON Serialization in Cache Tests

When testing cached data, remember JSON serialization converts Date to string:
```typescript
it("should return cached data when available", async () => {
  mockRedisGet.mockImplementation(() => Promise.resolve(JSON.stringify(cachedPeople)));
  
  const result = await service.getAll(TEST_USER_ID);
  
  // Compare structure, not exact equality (dates become strings)
  expect(result).toHaveLength(1);
  expect(result[0].id).toEqual(mockPerson.id);
});
```

#### Running Tests

```bash
# Run all tests
bun test

# Run specific test file
bun test tests/modules/people/people.service.test.ts

# Run tests in a directory
bun test tests/modules/people

# Run with timeout
bun test --timeout 30000

# Watch mode
bun test --watch
```

## Common Patterns

### Creating a New Module

1. Create folder: `src/modules/[feature]/`
2. Create files: `index.ts`, `[feature].routes.ts`, `[feature].service.ts`
3. Define service class with business logic
4. Define routes with validation and documentation
5. Export routes from index
6. Register routes in main `src/index.ts`

### Adding a Protected Route

```typescript
export const featureRoutes = new Elysia({ prefix: "/feature" })
  .use(authMiddleware)
  .get(
    "/protected",
    async ({ user }: { user: AuthUser }) => {
      // user is authenticated
      return { success: true, data: { userId: user.id } };
    },
    {
      detail: {
        tags: ["feature"],
        summary: "Protected endpoint",
        security: [{ bearerAuth: [] }]
      }
    }
  );
```

### Database Query Pattern

#### Basic Query

```typescript
export class UserService {
  async getUserById(userId: string) {
    const user = await db
      .selectFrom("users")
      .selectAll()
      .where("id", "=", userId)
      .executeTakeFirst();

    if (!user) {
      throw new Error("User not found");
    }

    return user;
  }
}
```

#### Optimized Multi-Table Query (JSON Aggregation)

For fetching related data in a single query, use PostgreSQL JSON functions:

```typescript
async getFullProfile(userId: string, personId: string): Promise<PersonProfile | null> {
  const query = sql<ProfileQueryResult>`
    SELECT
      row_to_json(p.*) as person,
      COALESCE(
        (SELECT json_agg(m.*) FROM memories m 
         WHERE m.person_id = p.id AND m.user_id = ${userId}),
        '[]'::json
      ) as memories,
      COALESCE(
        (SELECT json_agg(pl.*) FROM planner pl 
         WHERE pl.person_id = p.id AND pl.user_id = ${userId} 
         AND pl.date >= CURRENT_DATE AND pl.completed = false),
        '[]'::json
      ) as upcoming_plans,
      COALESCE(
        (SELECT json_agg(w.*) FROM wishlist w 
         WHERE w.person_id = p.id AND w.user_id = ${userId} 
         AND w.purchased = false),
        '[]'::json
      ) as wishlist
    FROM people p
    WHERE p.id = ${personId} AND p.user_id = ${userId}
  `;
  
  const result = await query.execute(db);
  const row = result.rows[0];
  
  if (!row?.person) return null;
  
  return {
    person: row.person,
    memories: row.memories || [],
    upcomingPlans: row.upcoming_plans || [],
    wishlist: row.wishlist || [],
  };
}
```

#### Cascading Delete with CTEs

For deleting a record and all related data in one atomic operation:

```typescript
async delete(userId: string, personId: string): Promise<boolean> {
  const query = sql<{ deleted_id: string | null }>`
    WITH delete_memories AS (
      DELETE FROM memories 
      WHERE person_id = ${personId} AND user_id = ${userId}
    ),
    delete_planner AS (
      DELETE FROM planner 
      WHERE person_id = ${personId} AND user_id = ${userId}
    ),
    delete_wishlist AS (
      DELETE FROM wishlist 
      WHERE person_id = ${personId} AND user_id = ${userId}
    )
    DELETE FROM people 
    WHERE id = ${personId} AND user_id = ${userId}
    RETURNING id as deleted_id
  `;
  
  const result = await query.execute(db);
  return result.rows[0]?.deleted_id !== null;
}
```

#### Performance Tips

- Use `json_agg` and `row_to_json` to fetch related data in one query
- Use CTEs (`WITH`) for cascading operations
- Add `COALESCE` with empty array default for nullable aggregations
- Always include `user_id` in WHERE clauses for security
- Use `CURRENT_DATE` for date comparisons in the database

### Error Handling Pattern

#### ServiceError Class

Create a custom error class for service-level errors:
```typescript
export type ErrorCode = "NOT_FOUND" | "VALIDATION" | "DATABASE" | "INTERNAL" | "CACHE";

export class ServiceError extends Error {
  constructor(
    message: string,
    public readonly code: ErrorCode,
    public readonly statusCode: number = 500
  ) {
    super(message);
    this.name = "ServiceError";
  }
}
```

#### Service Layer Error Handling

```typescript
async getById(userId: string, personId: string): Promise<Person | undefined> {
  try {
    const person = await db
      .selectFrom("people")
      .selectAll()
      .where("id", "=", personId)
      .where("user_id", "=", userId)
      .executeTakeFirst();
    return person;
  } catch (error) {
    logger.error("Failed to get person by ID", error as Error, { userId, personId });
    throw new ServiceError("Failed to retrieve person", "DATABASE", 500);
  }
}
```

#### Route Layer Error Handling

```typescript
// Helper function for consistent error responses
function handleError(error: unknown, set: { status: number }): { success: false; error: string } {
  if (error instanceof ServiceError) {
    set.status = error.statusCode;
    return { success: false, error: error.message };
  }
  logger.error("Unexpected error", error as Error);
  set.status = 500;
  return { success: false, error: "Internal server error" };
}

// Route handler
.post("/", async ({ user, body, set }) => {
  try {
    // Validation
    if (!body.name || body.name.length < 1) {
      set.status = 400;
      return { success: false, error: "Name is required" };
    }
    
    const person = await service.create({ user_id: user.id, ...body });
    set.status = 201;
    return { success: true, data: person, message: "Person created successfully" };
  } catch (error) {
    return handleError(error, set);
  }
})
```

#### HTTP Status Codes by Error Type

| Error Code | HTTP Status | Use Case |
|------------|-------------|----------|
| `NOT_FOUND` | 404 | Resource doesn't exist |
| `VALIDATION` | 400 | Invalid input data |
| `DATABASE` | 500 | Database operation failed |
| `INTERNAL` | 500 | Unexpected server error |
| `CACHE` | (don't fail) | Cache operations should not cause request failure |

## Remember

- Clean code is better than clever code
- Readability over brevity
- Type safety is paramount
- Test your code
- Document public APIs
- Handle errors gracefully
- Log important events
- Security first
- Performance matters
- Consistency is key

